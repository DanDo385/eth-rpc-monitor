# Ethereum RPC Monitor — Cursor Rules

## Project Context
Lightweight RPC endpoint monitor and block inspector for Ethereum.
Target: Portfolio project demonstrating Go proficiency, understanding of Ethereum JSON-RPC, and infrastructure thinking for institutional crypto roles.

## What This Project Is
- CLI tool monitoring RPC endpoint health, latency, and consistency
- Simple block inspector for verifying RPC responses
- Demonstrates operational awareness (latency matters for trading)

## What This Project Is NOT
- A geth/go-ethereum wrapper (we use raw HTTP)
- A trading bot or DeFi tool
- A web dashboard
- A wallet or signing tool

## Tech Stack
- Go 1.24+
- Dependencies (minimal):
  - `gopkg.in/yaml.v3` (config)
  - `golang.org/x/sync/errgroup` (concurrent provider calls)
  - `github.com/fatih/color` (terminal color formatting)
- Raw `net/http` for RPC (need latency visibility)
- **NO** `go-ethereum` packages
- **NO** CLI frameworks (simple `flag` package for args)

## Architecture
```
cmd/
├── block/
│   └── main.go      # Block inspector (fetch and display blocks)
├── snapshot/
│   └── main.go      # Cross-provider comparison (fork detection)
├── test/
│   └── main.go      # Provider health check (tail latency metrics)
└── monitor/
    └── main.go      # Continuous monitoring (real-time dashboard)

internal/
├── format/
│   ├── block.go     # Block formatting (human-readable output)
│   ├── snapshot.go  # Snapshot comparison formatting
│   ├── monitor.go   # Monitor dashboard formatting
│   ├── test.go      # Test results formatting with tail latency
│   └── colors.go    # Color helpers for terminal output
├── config/
│   └── config.go    # YAML loading, env var expansion
└── rpc/
    ├── client.go    # HTTP client with latency measurement
    ├── format.go    # Hex parsing, number formatting, unit conversion
    └── types.go     # Block, Request, Response structs

config/
└── providers.yaml   # Single source of truth for all config
```

## Commands
| Command | Description |
|---------|-------------|
| `block [block]` | Inspect block (default: latest, auto-selects fastest provider) |
| `test` | Test all providers, show tail latency stats (P50/P95/P99/Max) |
| `snapshot [block]` | Fetch same block from all providers, detect mismatches |
| `monitor` | Continuous monitoring with refresh interval (real-time dashboard) |

Commands support `-json` flag to output JSON reports to `reports/` directory.

## Configuration

### Single Source of Truth
All defaults live in `config/providers.yaml`. Go code inherits from YAML, never invents fallbacks.
```yaml
defaults:
  timeout: 10s
  health_samples: 30      # Default samples for test command
  watch_interval: 30s     # Default refresh interval for monitor command

providers:
  - name: alchemy
    url: ${ALCHEMY_URL}
    type: public
  - name: ankr
    url: https://rpc.ankr.com/eth
    type: public
```

### Environment Variables
URLs can use `${VAR}` syntax. Expanded at load time via `os.ExpandEnv()`.

## RPC Client Design

### JSON for Wire Protocol (Required)
Ethereum JSON-RPC requires JSON. The `json` struct tags in `types.go` are for the wire protocol, not config.

### Simplified Design
- No retry logic (assumes correct user input and reliable network)
- No client pooling (creates clients as needed)
- Direct HTTP calls with timeout
- Latency measurement for all requests

### Methods Needed
- `eth_blockNumber` - current height
- `eth_getBlockByNumber` - block details

## Output Modes

### Terminal (Default)
Human-readable with color formatting. Example:
```
Block #19,234,567
══════════════════════════════════════════════════
  Hash:         0xabcd1234...
  Timestamp:    2024-01-15 14:23:11 UTC (2m ago)
  Gas:          12,456,789 / 30,000,000 (41.5%)
  Transactions: 143

  Provider:     alchemy (23ms)
```

Color scheme:
- **Green**: Fast latency (<100ms), success indicators
- **Yellow**: Medium latency (100-300ms), warnings
- **Red**: Slow latency (>300ms), errors
- **Bold**: Headers and important labels
- **Dim**: Secondary information

### JSON (`-json` flag)
Machine-readable reports written to `reports/` directory with timestamped filenames.
Format: `{command}-{YYYYMMDD-HHMMSS}.json`

```bash
./bin/block latest -json           # Writes reports/block-20260120-124236.json
./bin/test -json                   # Writes reports/test-20260120-124251.json
./bin/snapshot latest -json        # Writes reports/snapshot-20260120-124628.json
./bin/monitor -json                # Writes reports/monitor-{timestamp}.json on exit (Ctrl+C)
```

JSON output includes:
- **block**: Decimal values (not hex), ISO 8601 timestamps, gwei for baseFeePerGas
- **test**: Raw latency samples, percentile calculations, block height mismatches
- **snapshot**: Grouped results by hash/height, mismatch detection
- **monitor**: Final snapshot with lag calculations

## Code Patterns

### Concurrency
Use `golang.org/x/sync/errgroup` for concurrent provider calls:
```go
g, gctx := errgroup.WithContext(ctx)
for _, p := range providers {
    p := p // capture loop variable
    g.Go(func() error {
        // Concurrent work with context cancellation
        return nil
    })
}
if err := g.Wait(); err != nil {
    return err
}
```

### Provider Selection (block command)
Race all providers concurrently, select fastest that's on latest block:
- Query all providers for `eth_blockNumber` concurrently
- Find highest block number (most up-to-date)
- Among providers on latest block, select fastest by latency
- Ensures both speed and correctness (no stale data)

### Warm-up Requests
Both `test` and `snapshot` commands perform a warm-up request before measurements:
- Eliminates connection setup overhead (TCP handshake, TLS negotiation, DNS lookup)
- Makes latency metrics more representative of actual RPC performance
- Warm-up result is discarded, only actual measurements are recorded

### Error Handling
- Wrap errors: `fmt.Errorf("context: %w", err)`
- Return up the stack, let main function display
- In JSON mode, errors to stderr only

### Hex Parsing
All Ethereum values are hex. Use utility functions from `internal/rpc/format.go`:
- `ParseHexUint64(hex string) (uint64, error)` - For values that fit in 64 bits
- `ParseHexBigInt(hex string) (*big.Int, error)` - For arbitrarily large values (e.g., baseFeePerGas)

### Percentile Calculation (test command)
Use nearest-rank method for correct percentile calculation:
```go
index := int(math.Ceil(float64(n)*p)) - 1
// Ensures P95/P99 = Max for small sample sizes (correct behavior)
```

### JSON Report Generation
Each command has an inline `writeJSON` helper function:
- Creates `reports/` directory if needed
- Generates timestamped filenames: `{prefix}-{YYYYMMDD-HHMMSS}.json`
- Pretty-printed JSON with 2-space indentation

## Code Quality Standards

### Documentation
- **All packages** must have package-level documentation explaining purpose
- **All exported functions** must have function-level documentation with:
  - Description of what the function does
  - Parameters (name, type, description)
  - Return values (type, description)
  - Examples where helpful
- **Complex logic** must have inline comments explaining the algorithm
- **Type definitions** must have comments explaining purpose and field meanings

### Do NOT
- Use `go-ethereum` or `ethclient`
- Add web UI or persistence
- Hardcode config values in Go (use YAML)
- Mix stdout/stderr in JSON mode (errors to stderr, JSON to stdout)
- Compare block hashes from different heights
- Add defensive validation (assume correct user input)
- Add retry logic or complex error handling (keep it simple)

## Testing After Every Change
```bash
# Build all commands using Makefile
make build

# Or build manually
go build -o bin/block ./cmd/block
go build -o bin/test ./cmd/test
go build -o bin/snapshot ./cmd/snapshot
go build -o bin/monitor ./cmd/monitor

# Test each command
./bin/block latest
./bin/block latest -json                  # Check reports/block-*.json
./bin/test -samples 5                     # Quick health check
./bin/test -json                          # Check reports/test-*.json
./bin/snapshot latest                     # Compare all providers
./bin/snapshot latest -json               # Check reports/snapshot-*.json
./bin/monitor -interval 5s                # Test monitoring (Ctrl+C to exit)
./bin/monitor -json                       # Test with JSON report on exit
```

Verify:
- All builds succeed without errors
- JSON reports are written to `reports/` directory
- Terminal output is properly formatted
- Error handling works correctly